flightwise/
├── app/
│   ├── __init__.py
│   ├── routes.py
│   ├── models.py
│   ├── ml/
│   │   ├── __init__.py
│   │   ├── regression.py
│   │   └── clustering.py
│   └── utils/
│       ├── __init__.py
│       ├── api_client.py
│       └── haversine.py
├── data/                 # se crea automáticamente si hace falta
├── tests/
│   └── test_api.py
├── run.py
├── train_model.py
└── requirements.txt
from app import create_app

app = create_app()

if __name__ == "__main__":
    # En desarrollo usar debug=True; en producción usar WSGI server
    app.run(host="0.0.0.0", port=5000, debug=True)
from flask import Flask
import os

def create_app():
    app = Flask(__name__, static_folder="../static", template_folder="../templates")
    app.config["JSON_SORT_KEYS"] = False
    # Registrar blueprint de rutas
    from .routes import main
    app.register_blueprint(main, url_prefix="")
    # Asegurar carpeta data
    os.makedirs("data", exist_ok=True)
    return app
from flask import Blueprint, request, jsonify
from .ml.regression import cargar_modelo, predecir_demora
from .utils.haversine import haversine
import os

main = Blueprint("main", __name__)

@main.route("/api/health", methods=["GET"])
def health():
    return jsonify({"status": "ok"})

@main.route("/api/data/summary", methods=["GET"])
def data_summary():
    # Resumen mínimo (ampliar con DB/EDA real)
    summary = {
        "n_vuelos_sample": 1000,
        "modelo_existe": os.path.exists(os.path.join("data", "modelo_regresion.pkl"))
    }
    return jsonify(summary)

@main.route("/api/predict/delay", methods=["POST"])
def predict_delay():
    """
    Entrada JSON esperada:
    {
      "origen": {"lat": float, "lon": float},
      "destino": {"lat": float, "lon": float},
      "viento": float,
      "temperatura": float
    }
    Respuesta:
    {
      "distancia_km": float,
      "prediccion_demora_min": float
    }
    """
    payload = request.get_json(force=True)
    try:
        origin = payload["origen"]
        dest = payload["destino"]
        viento = float(payload.get("viento", 0.0))
        temp = float(payload.get("temperatura", 15.0))
    except Exception as e:
        return jsonify({"error": "JSON mal formado o campos faltantes", "detail": str(e)}), 400

    distancia_km = haversine(origin["lat"], origin["lon"], dest["lat"], dest["lon"])
    try:
        model = cargar_modelo()
    except FileNotFoundError as e:
        return jsonify({"error": str(e)}), 500

    pred = predecir_demora(model, {"distancia": distancia_km, "viento": viento, "temperatura": temp})
    return jsonify({
        "distancia_km": round(distancia_km, 3),
        "prediccion_demora_min": pred
    })
# Placeholder para futuras extensiones con SQLAlchemy.
# Mantener para organización del proyecto.

# Ejemplo (opcional):
# from flask_sqlalchemy import SQLAlchemy
# db = SQLAlchemy()
#
# class Vuelo(db.Model):
#     id = db.Column(db.Integer, primary_key=True)
#     fecha = db.Column(db.DateTime)
#     origen = db.Column(db.String(8))
#     destino = db.Column(db.String(8))
#     demora_min = db.Column(db.Float)
# Paquete ml
import joblib
import os
import numpy as np

MODELO_PATH = os.path.join("data", "modelo_regresion.pkl")

def cargar_modelo():
    """
    Carga el modelo entrenado desde data/modelo_regresion.pkl
    Lanza FileNotFoundError si no existe.
    """
    if not os.path.exists(MODELO_PATH):
        raise FileNotFoundError(f"Modelo no encontrado en {MODELO_PATH}. Ejecuta train_model.py primero.")
    return joblib.load(MODELO_PATH)

def predecir_demora(modelo, datos):
    """
    datos: dict con keys 'distancia', 'viento', 'temperatura'
    Retorna float (minutos de demora)
    """
    X = np.array([[float(datos["distancia"]), float(datos["viento"]), float(datos["temperatura"])]])
    yhat = modelo.predict(X)
    return float(round(yhat[0], 2))
from sklearn.cluster import KMeans
import numpy as np

def entrenar_kmeans(X, k=4):
    km = KMeans(n_clusters=k, random_state=42, n_init=10)
    km.fit(X)
    return km

def asignar_cluster(modelo_km, X_new):
    X_arr = np.array(X_new)
    return modelo_km.predict(X_arr)
# Paquete utils
from math import radians, cos, sin, asin, sqrt

def haversine(lat1, lon1, lat2, lon2):
    """
    Calcula distancia en km entre dos puntos (lat, lon) usando Haversine.
    """
    R = 6371.0  # radio medio Tierra en km
    lat1_r, lon1_r, lat2_r, lon2_r = map(radians, [lat1, lon1, lat2, lon2])
    dlat = lat2_r - lat1_r
    dlon = lon2_r - lon1_r
    a = sin(dlat / 2)**2 + cos(lat1_r) * cos(lat2_r) * sin(dlon / 2)**2
    c = 2 * asin(sqrt(a))
    return R * c
import requests
import time

class SimpleAPIClient:
    """
    Cliente minimalista con manejo sencillo de paginación y retry por rate limit.
    Ajustar parámetros según cada API (cabeceras, auth).
    """
    def __init__(self, base_url, api_key=None, max_retries=3, backoff=1.0):
        self.base_url = base_url.rstrip("/")
        self.api_key = api_key
        self.max_retries = max_retries
        self.backoff = backoff

    def get(self, path, params=None, headers=None):
        url = f"{self.base_url}/{path.lstrip('/')}"
        params = params or {}
        headers = headers or {}
        if self.api_key:
            params["access_key"] = self.api_key  # cambiar si la API usa otro nombre
        attempt = 0
        while attempt < self.max_retries:
            r = requests.get(url, params=params, headers=headers, timeout=15)
            if r.status_code == 200:
                return r.json()
            elif r.status_code == 429:
                time.sleep(self.backoff * (attempt + 1))
                attempt += 1
            else:
                r.raise_for_status()
        raise RuntimeError("Max retries alcanzado para GET " + url)
"""
Genera datos sintéticos (si no hay CSV) y entrena un modelo de regresión.
Guarda modelo en data/modelo_regresion.pkl
"""
import pandas as pd
from sklearn.linear_model import LinearRegression, Ridge, Lasso
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_squared_error
import joblib
import os
import numpy as np

DATA_PATH = os.path.join("data", "vuelos_sample.csv")
MODEL_PATH = os.path.join("data", "modelo_regresion.pkl")

def cargar_datos(path=DATA_PATH):
    if not os.path.exists(path):
        np.random.seed(42)
        n = 1000
        distancia = np.random.uniform(50, 3000, n)
        viento = np.random.uniform(0, 40, n)
        temperatura = np.random.uniform(-10, 35, n)
        demora = 0.005 * distancia + 0.3 * viento - 0.1 * (temperatura - 15) + np.random.normal(0, 5, n)
        df = pd.DataFrame({
            "distancia": distancia,
            "viento": viento,
            "temperatura": temperatura,
            "demora_minutos": demora
        })
        os.makedirs("data", exist_ok=True)
        df.to_csv(path, index=False)
        return df
    return pd.read_csv(path)

def entrenar_y_guardar():
    df = cargar_datos()
    X = df[["distancia", "viento", "temperatura"]]
    y = df["demora_minutos"]
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    models = {
        "Linear": LinearRegression(),
        "Ridge": Ridge(alpha=1.0),
        "Lasso": Lasso(alpha=0.1)
    }
    mejor = None
    mejor_rmse = float("inf")
    for name, m in models.items():
        m.fit(X_train, y_train)
        preds = m.predict(X_test)
        rmse = mean_squared_error(y_test, preds, squared=False)
        r2 = r2_score(y_test, preds)
        print(f"{name}: RMSE={rmse:.3f}, R2={r2:.3f}")
        if rmse < mejor_rmse:
            mejor_rmse = rmse
            mejor = m

    os.makedirs("data", exist_ok=True)
    joblib.dump(mejor, MODEL_PATH)
    print(f"Modelo guardado en {MODEL_PATH}")

if __name__ == "__main__":
    entrenar_y_guardar()

import json
from app import create_app
import os
import pytest

@pytest.fixture
def client():
    app = create_app()
    app.config["TESTING"] = True
    with app.test_client() as client:
        yield client

def test_health(client):
    r = client.get("/api/health")
    assert r.status_code == 200
    data = r.get_json()
    assert data.get("status") == "ok"

def test_predict_delay_smoke(client):
    payload = {
        "origen": {"lat": 40.472, "lon": -3.561},
        "destino": {"lat": 51.470, "lon": -0.454},
        "viento": 10,
        "temperatura": 12
    }
    model_path = os.path.join("data", "modelo_regresion.pkl")
    if not os.path.exists(model_path):
        import train_model
        train_model.entrenar_y_guardar()

    r = client.post("/api/predict/delay", data=json.dumps(payload), content_type="application/json")
    assert r.status_code == 200
    j = r.get_json()
    assert "prediccion_demora_min" in j
    assert j["distancia_km"] > 0
flask>=2.0
requests>=2.25
scikit-learn>=1.0
pandas>=1.3
numpy>=1.21
joblib>=1.0
pytest>=7.0

